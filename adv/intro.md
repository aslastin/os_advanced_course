## Вычисления как физический процесс

-  __Логически__: реализуем архитектуру фон Неймана на полупроводниковых структурах. Модель современных компьютеров проста: есть память, которая может хранить два типа информации (исполняемый код и данные, то, с чем этому коду работать), процессор и система взаимодействия с внешним миров (ввод-вывод).

- __Процессор, соображения производительности.__ _Процессор_ - некая вычислительная структура, позволяющая выполнять простые команды + эти команды должны выполняться быстро. 

- __Постоянное хранилище, диск: хранение и передача программ.__

- __Временное хранилище, память: изоляция контекстов исполнения.__ Существует механизм, позволяющий данные одной программы не показывать другим.

- __Таймер и прерываемость исполнения__ - возможность организации ввода-вывода и тривиальной многозадачности.

- __Сетевая коммуникация__ - какой- то ввод-вывод, обеспечивающий взаимодействие компьютеров между собой.

- __Ввод от человека.__ Необходимо взаимодействовать с машиной.

- __Вывод человеку.__


## Зачем ОС? Почему просто не писать полезные программы? 

## Немного истории

- 1938 - Z1. Германия. (Нет ОС. Была вычислительная программа: Терминал, Ввод, Вывод)

- 1946 - ENIAC. Первый промышленный компьютер. Использовался в основном большими правительственными структурами. (Нет ОС)

- 1964 - IBM S/360 (BOS, TOS, DOS - первые ОС). Монитор, наблюдающий за ходом исполнения.

- 1967 - GE 645 и Multics (вытесняющая многозадачность, зашита памяти)

- 1970 - PDP-11 и UNIX (на ассемблере)

- 1973 - UNIX переписан на C (потомок языка B + для системного кодинга), стала возможность портируемости. 

- 1977 - VAX и VMS. 

- 1981 - IBM PC и MS DOS. Революция процессоров.

- 1983 - IBM PC и Windows 1.0.

- 1984 - Macintosh и System 1 (потом Mac OS). Системное программное обеспечение стала тем, с чем человек может взаимодействовать.

- 1988 - стандарт на userland UNIX, POSIX (portable operation system interface).

- 1993 - Windows NT

- 2000 - Mac и macOS (Mac OS X).


## Функционал расширяется…

- __Монитор исполнения.__ Изначально ОС выполняла роль supervisor.

- __Абстракция процесса.__ Когда был монитор исполнения, компьютер мог выполнять только одну программу. Из-за необходимости многозадачности необходимо было ввести понятие непрерывного потока инструкций.

- __Абстракция терминала.__

- __Абстракция файловой системы.__ Первоначально информация на постоянных носителях организовывалась в виде заголовков, например: `<String, int, int>` -> память ->  обработка. Затем, когда появились сложные данные, потребовалась абстракция файловой системы.

- __Абстракция коммуникационного канала (socket).__ Для взаимодействия с другими ОС был придуман _socket_: можем записать байты в логическое место одной стороны, и прочитать эти данные с другой стороны.  

- __Абстракция видеокарты (фреймбуффер, 3D ускорение)__. Современное устройство для работы с графической информацией (ОС предоставляла буффер для этого, например, в RGB формате).

- __Абстракция устройств ввода (мышь, тачскрин).__ Уровень трансляции между вводом и сообщением о происходящем брала на себя ОС.

- __Метасервисы: безопасность, портируемость, отладка, профилировка.__  Появляется поверх более удобного способа взаимодействия с периферийными устройствами возможность обеспечить безопасность. 


## Архитектура

![1.1 architecture](https://raw.githubusercontent.com/aslastin/os_course/master/images/1.1%20architecture.png?token=AOQTE37P2XYTISY3M6KOMQC7NUCEU)

ОС могут быть устроены по-разному. В современной ОС существует 3 логических уровня: 

1) _Уровень аппаратного обеспечения_ - то, что исполняет те или иные действия (мониторы, диски). 

2) _ОС + Kernel Space_ (например, драйвера). 

3) _User Space_ (User Processes/Applications/Programs)  - программы написанные пользователем. 

Такая архитектура показала себя жизнеспособной за счет следующего: каждый уровень наделены разным уровнем привилегий (разным набором прав того, что можно делать). _Kernel Space_ - оборудование, прерывания. _Пользовательские_ - взаимодействуют напрямую не с оборудованием, а с интерфейсами ОС. А уже интерфейсы решают, что предоставить/показать. 


## Что в ядре?

- __Монитор исполнения/планировщик.__ Обеспечивают возможность программам исполняться одновременно, разделяя одни и те же ресурсы.

- __Менеджер виртуальной памяти (manager virtual memory).__ Физическая память - массив страниц, индексируемых своим номером. Можно прочитать/записать данные из этих страниц. Если говорить на высоком уровне, MVM обеспечивает возможность разделения этого массива на набор логических виртуальных массивов, которые называются _адресными пространствами_ процесса, то есть тем регионом памяти, который некоторым образом отображается на реальную физическую память, но показывает процессу, что он уже в своем неограниченном мире (без необходимости знать о других процессах).

- __Менеджер межпроцессного взаимодействия.__ Процесс/ядро.

- __Реализацией файловой системы.__ 

- __Реализация драйвера оборудования__ - код, взаимодействующий с теми или иными полупроводниковыми конструкциями).

- __Реализация загрузчика исполняемых форматов.__ ОС взаимодействует с программами, исполняемый формат которых она понимает. Загрузчик исполняемых форматов обеспечивает возможность ядру ОС взаимодействовать с разными процессами. 

__Что обязательно?__ : менеджер исполнения/планировщик, MVM, менеджер межпроцессного взаимодействия, базовый загрузчик исполняемых форматов (не всегда).  

Существует 2 философских школы: _микроядро_ (попадает самый голый минимум, в такой системе можем очень доверять) или _монолитное ядро_ (все на высшем уровне привилегий - файловая система, графические примитивы и т д). 

__Что же лучше?__

- Выводим из требований.

- Производительность - монолитное ядро.

- Стабильность - микроядро.

- Удобство разработки - монолитное ядро.

- Расширяемость системы - зависит от уровня стабильности мехкомпонентных интерфейсов.

- Безопасность - микроядро.

- Наблюдаемость - возможность трассировки, отладки - микроядро.








